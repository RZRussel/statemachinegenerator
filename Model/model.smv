-- Module for modeling penguin's snowball actor --
MODULE Snowball(world, owner)

  DEFINE 
    d_radius := 100;
  	d_fly_velocity := 12;

  -- relations --
  DEFINE
    FlyOX := 
      case
        direction in 0..90 : 1;
        TRUE : 0;
      esac;

    FlyOY := 
      case
        direction in 0..90 : 1;
        TRUE : 0;
      esac;

    CollisionDetected := 
      case
        next(x) - next(owner.opponent.x) = 0 & next(y) - next(owner.opponent.y) = 0 : TRUE;
        TRUE: FALSE;
      esac;

    DeadPointReached := 
      case
        next(x) = 0 & next(y) = 0 : TRUE;
        TRUE : FALSE;
      esac;

  VAR
    x: 0..world.d_max_x; -- x position in the world --
    y: 0..world.d_max_y; -- y position in the world --
    fly_flag: boolean; -- flag states whether the snowball was thrown and active --
    direction: 0..359; -- current flying direction --

  -- initial state --
  ASSIGN 
    x := 0;
    y := 0;
    direction := 0;
    fly_flag := FALSE;

  DEFINE
    Deact := !fly_flag & !next(fly_flag) & next(x) = x & next(y) = y 
      & next(direction) = direction;

    Fly := fly_flag & !bool(owner.opponent.snowball_collision) & next(x) = x + FlyOX & next(y) = y + FlyOY
      & (bool(next(owner.opponent.snowball_collision)) = CollisionDetected & !next(owner.opponent.dead)
          & next(fly_flag) | next(owner.opponent.snowball_collision) = owner.opponent.snowball_collision)
      & next(fly_flag) = !DeadPointReached;

    Collide := bool(owner.opponent.snowball_collision) & !next(bool(owner.opponent.snowball_collision))
      & fly_flag & !owner.opponent.dead & !next(fly_flag)
        & (owner.opponent.pushing_index = 0  & next(owner.opponent.stun_timer) = owner.opponent.d_stun_timer_max
          | owner.opponent.pushing_index > 0);

  -- snowball's state possible transitions --
  TRANS
    Fly & !owner.Throw & !Deact & !Collide
    | !Fly & owner.Throw & !Deact & !Collide
    | !Fly & !owner.Throw & Deact & !Collide
    | !Fly & !owner.Throw & !Deact & Collide;


-- Module for modeling penguin actor --
MODULE Penguin(world, opponent)
	
  -- constants --
  DEFINE
  	d_move_velocity := 54;	-- all penguins can perform move action with const velocity
  	d_radius := 270;			-- penguin's body is a circle with const radius
  	d_stun_timer_max := 30;	-- time for which penguin freezes after got hit with a snowball
  	d_pushing_index_max := 10; -- initial index in the pushing velocity array
  	d_pushing_velocity := 50; -- initial velocity after push action
  	d_pushing_timer_max := 60;  -- time during which penguin can't perform push action again
  	d_snowball_timer_max := 60; -- time during which penguin can't perform throwing snowball again

  -- relations --
  DEFINE
    MoveNext := 
      next(direction) in 0..44 & next(x) = x + 7 & next(y) = y
      | next(direction) in 45..89 & next(x) = x + 7 & next(y) = y + 7
      | next(direction) in 90..134 & next(x) = x - 7 & next(y) = y + 7
      | next(direction) in 135..180 & next(x) = x - 7 & next(y) = y
      | next(direction) in 181..269 & next(x) = x - 7 & next(y) = y - 7
      | next(direction) in 270..359 & next(x) = x + 7 & next(y) = y - 7;

    SnowballInit :=
      next(snowball.direction) in 0..90 & next(snowball.x) = x + 0 & next(snowball.y) = y + 0
      | next(snowball.direction) in 90..359 & next(snowball.x) = x + 1 & next(snowball.y) = y + 1;
    
    PushingOx :=
      case
        pushing_index = d_pushing_index_max & direction in 0..20 : 1;
        TRUE: 0;
      esac;

    PushingOy :=
      case
        pushing_index = d_pushing_index_max & direction in 0..20 : 1;
        TRUE: 0;
      esac;

    PushedOx :=
      case
        pushed_velocity = 10 & pushed_index = 5 & direction in 0..20 : 1;
        TRUE: 0;
      esac;

    PushedOy :=
      case
        pushed_velocity = 10 & pushed_index = 5 & direction in 0..20 : 1;
        TRUE: 0;
      esac;

    PushedVelocity :=
      case
        pushed_index = 10 & pushed_velocity = 10 : 1;
        TRUE: 0;
      esac;

    PushedInitIndex :=
      case
        next(pushed_velocity) = 10: 10;
        TRUE: 9;
      esac;

    CollisionStaticStatic :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 : (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionStaticPushing :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & opponent.pushing_index = 10: (0d10_1 :: 0d10_0);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionStaticPushed :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & opponent.PushedVelocity = 10: (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushingStatic :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0
          & pushing_index = 10 : (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushingPushing :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & pushing_index = 10 & opponent.pushing_index = 10: (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushingPushed :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & pushing_index = 10 & opponent.PushedVelocity = 10: (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushedStatic :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0
          & PushedVelocity = 10 : (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushedPushing :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & PushedVelocity = 10 & opponent.pushing_index = 10: (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionPushedPushed :=
      case
        x - opponent.x = 1 & y - opponent.y = 1 & direction = 0 & opponent.direction = 0 
          & PushedVelocity = 10 & opponent.PushedVelocity = 10: (0d10_1 :: 0d10_1);
        TRUE: (0d10_1 :: 0d10_1);
      esac;

    CollisionDetected :=
      case
        next(x) - next(opponent.x) = 0 & next(y) - next(opponent.y) = 0 : TRUE;
        TRUE: FALSE;
      esac;

    DeadPointReached := 
      case
        next(x) = 0 & next(y) = 0 : TRUE;
        TRUE : FALSE;
      esac;

  VAR
  	x: 0..world.d_max_x; -- current x penguin's position in the world
  	y: 0..world.d_max_y; -- current y penguin's position in the world
  	direction: 0..359; -- current pushing, pushed or moved direction
  	stun_timer: 0..d_stun_timer_max; -- current remained time during which penguin can do nothing
  	pushing_index: 0..d_pushing_index_max; -- current index of the pushing velocity in the array
  	pushing_timer: 0..d_pushing_timer_max; -- current remained time during which penguin can't perform push action
  	pushed_index: 0..world.d_penguin_pushed_index_max; -- current velocity index of the pushed penguin
  	pushed_velocity: 0..world.d_penguin_pushed_velocity_max; -- initial velocity penguin received after the push
    dead: boolean; -- flag states whether penguin dead
    penguin_collision: unsigned word[1]; -- flags states whether there is a collision with i-th penguin
  	snowball_collision: unsigned word[1]; -- flags states whether there is a collision with i-th snowball
  	snowball_timer: 0..d_snowball_timer_max; -- current remained time during which a penguin can't perform throw action
    snowball: Snowball(world, self); -- penguin's snoball reference

  -- initial state --
  ASSIGN
    stun_timer := 0;
    pushing_index := 0;
    pushing_timer := 0;
    pushed_index := 0;
    pushed_velocity := 0;
    dead := FALSE;
    penguin_collision := 0b_0;
    snowball_collision := 0b_0;
    snowball_timer := 0;

-- action definitions --
  DEFINE
    Move := !dead & stun_timer = 0 & pushing_index = 0 & pushed_index = 0
      & !bool(penguin_collision) & !bool(snowball_collision)
      & next(pushing_index) = 0 & next(pushed_index) = 0 & next(pushed_velocity) = pushed_velocity
      & next(stun_timer) = 0 & snowball_timer < d_snowball_timer_max
      & MoveNext & next(dead) = DeadPointReached
      & (bool(next(penguin_collision)) = CollisionDetected & !next(dead) & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);

    Throw := !dead & stun_timer = 0 & pushing_index = 0 & next(pushing_index) = 0
      & !bool(penguin_collision) & !bool(snowball_collision)
      & snowball_timer = 0 & next(snowball_timer) = d_snowball_timer_max
      & (pushed_index > 0 | next(x) = x & next(y) = y)
      & next(snowball.fly_flag) & SnowballInit
      & (bool(next(penguin_collision)) = CollisionDetected & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);

    Push := !dead & stun_timer = 0 & pushed_index = 0 & pushing_timer = 0
      & !bool(penguin_collision) & !bool(snowball_collision)
      & next(pushing_index) = d_pushing_index_max & next(pushing_timer) = d_pushing_timer_max
      & next(x) = x & next(y) = y & next(pushed_index) = 0 & next(pushed_velocity) = pushed_velocity
      & (bool(next(penguin_collision)) = CollisionDetected & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);

    Stay := !dead & pushing_index = 0 & pushed_index = 0
      & !bool(penguin_collision) & !bool(snowball_collision)
      & next(x) = x & next(y) = y & next(pushing_index) = 0 & next(snowball_timer) < d_snowball_timer_max
      & next(pushed_index) = 0 & next(pushed_velocity) = pushed_velocity
      & (bool(next(penguin_collision)) = CollisionDetected & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);

    Dead := dead & next(dead) & next(x) = x & next(y) = y & next(direction) = direction
      & next(pushing_index) = pushing_index & next(pushed_index) = pushed_index
      & next(pushed_velocity) = pushed_velocity & next(penguin_collision) = penguin_collision
      & next(snowball_collision) = snowball_collision & next(stun_timer) < d_stun_timer_max
      & next(snowball_timer) < d_snowball_timer_max & next(pushing_timer) < d_pushing_timer_max;

    Pushing := !dead & pushing_index > 0 & pushed_index = 0 & stun_timer = 0 & !bool(penguin_collision)
      & next(pushing_index) = pushing_index - 1 & next(pushed_index) = 0
      & next(pushed_velocity) = pushed_velocity & next(stun_timer) = 0 & next(snowball_timer) < d_snowball_timer_max
      & next(direction) = direction & next(x) = x + PushingOx & next(y) = y + PushingOy
      & next(dead) = DeadPointReached
      & (bool(next(penguin_collision)) = CollisionDetected & !next(dead) & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);
    
    Pushed := !dead & pushing_index = 0 & pushed_index > 0 & !bool(penguin_collision)
      & next(pushed_index) = pushed_index - 1 & next(pushed_velocity) = pushed_velocity
      & next(pushing_index) = pushing_index & next(pushing_timer) < d_pushing_timer_max & next(direction) = direction
      & next(x) = x + PushedOx & next(y) = y + PushedOy
      & next(dead) = DeadPointReached
      & (bool(next(penguin_collision)) = CollisionDetected & !next(dead) & !next(opponent.dead) 
        | next(penguin_collision) = penguin_collision);

    Collide := bool(penguin_collision) & !bool(next(penguin_collision)) & !dead & !(opponent.dead)
      & ((pushing_index = 0 & pushed_index = 0
          & ((opponent.pushing_index = 0 & opponent.pushed_index = 0 
              & next(direction) = toint(CollisionStaticStatic[9:0]) & next(pushed_velocity) = toint(CollisionStaticStatic[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index > 0 & opponent.pushed_index = 0
              & next(direction) = toint(CollisionStaticPushing[9:0]) & next(pushed_velocity) = toint(CollisionStaticPushing[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index = 0 & opponent.pushed_index > 0
              & next(direction) = toint(CollisionStaticPushed[9:0]) & next(pushed_velocity) = toint(CollisionStaticPushed[19:10])
              & next(pushed_index) = PushedInitIndex)))
      | (pushing_index > 0 & pushed_index = 0
          & ((opponent.pushing_index = 0 & opponent.pushed_index = 0 
              & next(direction) = toint(CollisionPushingStatic[9:0]) & next(pushed_velocity) = toint(CollisionPushingStatic[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index > 0 & opponent.pushed_index = 0
              & next(direction) = toint(CollisionPushingPushing[9:0]) & next(pushed_velocity) = toint(CollisionPushingPushing[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index = 0 & opponent.pushed_index > 0
              & next(direction) = toint(CollisionPushingPushed[9:0]) & next(pushed_velocity) = toint(CollisionPushingPushed[19:10])
              & next(pushed_index) = PushedInitIndex)))
      | (pushing_index = 0 & pushed_index > 0
          & ((opponent.pushing_index = 0 & opponent.pushed_index = 0 
              & next(direction) = toint(CollisionPushedStatic[9:0]) & next(pushed_velocity) = toint(CollisionPushedStatic[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index > 0 & opponent.pushed_index = 0
              & next(direction) = toint(CollisionPushedPushing[9:0]) & next(pushed_velocity) = toint(CollisionPushedPushing[19:10])
              & next(pushed_index) = PushedInitIndex)
          | (opponent.pushing_index = 0 & opponent.pushed_index > 0
              & next(direction) = toint(CollisionPushedPushed[9:0]) & next(pushed_velocity) = toint(CollisionPushedPushed[19:10])
              & next(pushed_index) = PushedInitIndex))))
      & next(pushing_index) = 0;

    TickStunTimer := stun_timer = 0 & (next(stun_timer) = 0 | next(stun_timer) = d_stun_timer_max)
      | stun_timer > 0 & (next(stun_timer) = stun_timer - 1 | next(stun_timer) = d_stun_timer_max);

    TickPushingTimer := pushing_timer = 0 & (next(pushing_timer) = 0 | next(pushing_timer) = d_pushing_timer_max)
      | pushing_timer > 0 & next(pushing_timer) = pushing_timer - 1;

    TickBallTimer := snowball_timer = 0 & (next(snowball_timer) = 0 | next(snowball_timer) = d_snowball_timer_max)
      | snowball_timer > 0 & next(snowball_timer) = snowball_timer - 1;

  TRANS
    (Move & !Throw & !Push & !Stay & !Pushing & !Pushed & !snowball.Collide & !Collide & !Dead
      | !Move & Throw & !Push & !Stay & !Pushing & !snowball.Collide & !Collide & !Dead
      | !Move & !Throw & Push & !Stay & !Pushing & !Pushed & !snowball.Collide & !Collide & !Dead
      | !Move & !Throw & !Push & Stay & !Pushing & !Pushed & !snowball.Collide & !Collide & !Dead
      | !Move & !Throw & !Push & !Stay & Pushing & !Pushed & !snowball.Collide & !Collide & !Dead
      | !Move & !Push & !Stay & !Pushing & Pushed & !snowball.Collide & !Collide & !Dead
      | !Move & !Throw & !Push & !Stay & !Pushing & !Pushed & (snowball.Collide | Collide) & !Dead
      | !Move & !Throw & !Push & !Stay & !Pushing & !Pushed & !snowball.Collide & !Collide & Dead)
    & TickStunTimer & TickPushingTimer & TickBallTimer;

-- Module for modeling island actor --
MODULE Island(world)
  
  DEFINE
    d_center_x := 3680; -- island's x position in the world
    d_center_y := 2070; -- island's y position in the world
    d_small_radius := 1625; -- island's elepsis body small radius
    d_big_radius := 2515; -- island's elepsis body big radius

-- Module for modeling world actor --
MODULE World

  DEFINE
  	d_max_x := 7360; -- 2D world's width
  	d_max_y := 4140; -- 2D world's height
  	d_penguin_pushed_index_max := 10; -- maximum index penguin can have when pushed
  	d_penguin_pushed_velocity_max := 50; -- maximum velocity penguin can have when pushed 

  VAR
  	i: Island(self); -- there is 1 island in the world
    p1: Penguin(self, p2); -- there are 2 penguins in the world
    p2: Penguin(self, p1);

MODULE main  

  VAR
    world: World;

  JUSTICE TRUE;

  CTLSPEC
    AG EF (world.p1.dead | world.p2.dead); -- from any game state there is an opportunity to finish the game